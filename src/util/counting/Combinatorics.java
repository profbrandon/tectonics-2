package util.counting;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import util.Preconditions;
import util.data.algebraic.HomTuple;
import util.data.algebraic.Prod;

/**
 * Utility class for storing functions related to generating combinations of objects.
 */
public final class Combinatorics {
    
    /**
     * Function to compute the collection of ordered n-tuples given a finite list of elements to choose from.
     * Technically this computes the following:<p/>
     * 
     * {@code (a_i)_(i=0)^n } such that {@code a_i in as}
     * 
     * <p/>
     * For example, the list generated by {@link Ordinal#TWO_SET} and {@code [ 0, 1 ]} is the list
     * {@code [ (0, 0), (0, 1), (1, 0), (1, 1) ]}
     * 
     * @param <A> the element type
     * @param <N> the cardinality (tuple size)
     * @param enumerated the set of ordinals of the given cardinality
     * @param as the collection of elements to populate the tuples with
     * @return a list of n-tuples of elements of the provided list
     */
    public static <A, N extends Cardinal> List<HomTuple<N, A>> nProduct(final List<Ordinal<N>> enumerated, final List<A> as) {
        return nProduct(enumerated.size(), as)
            .stream()
            .map(xs -> 
                new HomTuple<>(Ordinal.buildPartition(
                    withIndex(xs)
                        .stream()
                        .map(pair -> Prod.mapFirst(pair, enumerated::get))
                        .toList())))
            .toList();
    }

    /**
     * Function to compute the collection of ordered n-tuples given a finite list of elements to choose from.
     * Technically this computes the following:<p/>
     * 
     * {@code (a_i)_(i=0)^n } such that {@code a_i in as}
     * 
     * <p/>
     * For example, the list generated by the arguments {@code 2} and {@code [ 0, 1 ]} is the list
     * {@code [ [ 0, 0 ], [ 0, 1 ], [ 1, 0 ], [ 1, 1 ] ]}
     * 
     * @param <A> the element type
     * @param n the size of the sublists to generate (n-tuples)
     * @param as the collection of elements to populate the tuples with
     * @return a list of n-tuples of elements of the provided list
     */
    public static <A> List<List<A>> nProduct(final int n, final List<A> as) {
        Preconditions.throwIfSatisfies(n, x -> x < 0, "Negative argument");
        switch (n) {
            case 0:
                return List.of();
            case 1:
                return as.stream().map(a -> List.of(a)).toList();
            default:
                final List<List<A>> smallShuffles = nProduct(n - 1, as);
                return as.stream()
                    .flatMap(a -> smallShuffles
                        .stream()
                        .map(xs -> Stream.concat(Stream.of(a), xs.stream()).toList()))
                    .toList();
        }
    }

    /**
     * Builds a list of pairs where the first element of the pair is the index of the element and
     * the second element is the corresponding element of the original list, i.e.,
     * <p/>
     * {@code withIndex(as).get(i).first() == i}
     * <p/>
     * {@code withIndex(as).get(i).second() == as.get(i) }
     * 
     * @param <A> the type of elements in the original list
     * @param as the original list
     * @return a list satisfying the above for all indices
     */
    public static <A> List<Prod<Integer, A>> withIndex(final List<A> as) {
        final List<Prod<Integer, A>> xs = new ArrayList<>();
        
        for (int i = 0; i < as.size(); ++i) {
            xs.add(Prod.pair(i, as.get(i)));
        }

        return xs;
    }

    /**
     * Builds the cartesian product of two lists (i.e. all possible pairs of elements of both lists).
     * 
     * @param <A> the type of elements present in the first list
     * @param <B> the type of elements present in the second list
     * @param as the first list
     * @param bs the second list
     * @return the cartesian product list
     */
    public static <A, B> List<Prod<A, B>> cartesianProduct(final List<A> as, final List<B> bs) {
        final List<Prod<A, B>> xs = new ArrayList<>();

        for (final A a : as) {
            for (final B b : bs) {
                xs.add(Prod.pair(a, b));
            }
        }

        return xs;
    }
}
